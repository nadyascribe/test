// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: attestation.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const createEvidence = `-- name: CreateEvidence :one
INSERT INTO osint."Attestation" (
    "key",
    "teamId",
    "contentType",
    "contextType",
    "context",
    "pipelineRun",
    "targetType",
    "targetName",
    "logical_app",
    "logical_app_version",
    "tool"
) VALUES (
    $1,
    $2::BIGINT,
    $3::TEXT,
    $4::TEXT,
    $5::jsonb,
    $6::BIGINT,
    $7::TEXT,
    $8::TEXT,
    --these fields may be null so don't cast to text
    $9,
    $10,
    $11
)
RETURNING id, "contentType", "targetType", "targetName", "contextType", context, key, timestamp, "userId", "teamId", "pipelineRun", state, "sigStatus", alerted, license, deleted, job_ids, txt, project, logical_app, logical_app_version, tool
`

type CreateEvidenceParams struct {
	Key               *string         `json:"key"`
	Teamid            int64           `json:"teamid"`
	Contenttype       string          `json:"contenttype"`
	Contexttype       string          `json:"contexttype"`
	Context           json.RawMessage `json:"context"`
	Pipelinerun       int64           `json:"pipelinerun"`
	Targettype        string          `json:"targettype"`
	Targetname        string          `json:"targetname"`
	Logicalapp        *string         `json:"logicalapp"`
	Logicalappversion *string         `json:"logicalappversion"`
	Tool              *string         `json:"tool"`
}

func (q *Queries) CreateEvidence(ctx context.Context, arg CreateEvidenceParams) (OsintAttestation, error) {
	row := q.queryRow(ctx, q.createEvidenceStmt, createEvidence,
		arg.Key,
		arg.Teamid,
		arg.Contenttype,
		arg.Contexttype,
		arg.Context,
		arg.Pipelinerun,
		arg.Targettype,
		arg.Targetname,
		arg.Logicalapp,
		arg.Logicalappversion,
		arg.Tool,
	)
	var i OsintAttestation
	err := row.Scan(
		&i.ID,
		&i.ContentType,
		&i.TargetType,
		&i.TargetName,
		&i.ContextType,
		&i.Context,
		&i.Key,
		&i.Timestamp,
		&i.UserId,
		&i.TeamId,
		&i.PipelineRun,
		&i.State,
		&i.SigStatus,
		&i.Alerted,
		&i.License,
		&i.Deleted,
		pq.Array(&i.JobIds),
		&i.Txt,
		&i.Project,
		&i.LogicalApp,
		&i.LogicalAppVersion,
		&i.Tool,
	)
	return i, err
}

const deleteEvidence = `-- name: DeleteEvidence :exec
DELETE FROM osint."Attestation"
WHERE
    "teamId" = $1::BIGINT AND
    CASE WHEN $2::BIGINT > 0 THEN
        id = $2::BIGINT
    ELSE
        CASE WHEN $3::TEXT <> '' THEN
            CASE WHEN strpos($3::TEXT, '%') > 0 THEN
                key LIKE $3::TEXT
            ELSE
                key = $3::TEXT
            END
        ELSE
            TRUE
        END
    END
`

type DeleteEvidenceParams struct {
	Teamid int64  `json:"teamid"`
	ID     int64  `json:"id"`
	Key    string `json:"key"`
}

func (q *Queries) DeleteEvidence(ctx context.Context, arg DeleteEvidenceParams) error {
	_, err := q.exec(ctx, q.deleteEvidenceStmt, deleteEvidence, arg.Teamid, arg.ID, arg.Key)
	return err
}

const getEvidenceByFileID = `-- name: GetEvidenceByFileID :one
SELECT
    id, "contentType", "targetType", "targetName", "contextType", context, key, timestamp, "userId", "teamId", "pipelineRun", state, "sigStatus", alerted, license, deleted, job_ids, txt, project, logical_app, logical_app_version, tool
FROM
    osint."Attestation"
WHERE
    id = $1
`

func (q *Queries) GetEvidenceByFileID(ctx context.Context, id int64) (OsintAttestation, error) {
	row := q.queryRow(ctx, q.getEvidenceByFileIDStmt, getEvidenceByFileID, id)
	var i OsintAttestation
	err := row.Scan(
		&i.ID,
		&i.ContentType,
		&i.TargetType,
		&i.TargetName,
		&i.ContextType,
		&i.Context,
		&i.Key,
		&i.Timestamp,
		&i.UserId,
		&i.TeamId,
		&i.PipelineRun,
		&i.State,
		&i.SigStatus,
		&i.Alerted,
		&i.License,
		&i.Deleted,
		pq.Array(&i.JobIds),
		&i.Txt,
		&i.Project,
		&i.LogicalApp,
		&i.LogicalAppVersion,
		&i.Tool,
	)
	return i, err
}

const getEvidenceByKey = `-- name: GetEvidenceByKey :one
SELECT
    id, "contentType", "targetType", "targetName", "contextType", context, key, timestamp, "userId", "teamId", "pipelineRun", state, "sigStatus", alerted, license, deleted, job_ids, txt, project, logical_app, logical_app_version, tool
FROM
    osint."Attestation"
WHERE
    key = $1
`

func (q *Queries) GetEvidenceByKey(ctx context.Context, key *string) (OsintAttestation, error) {
	row := q.queryRow(ctx, q.getEvidenceByKeyStmt, getEvidenceByKey, key)
	var i OsintAttestation
	err := row.Scan(
		&i.ID,
		&i.ContentType,
		&i.TargetType,
		&i.TargetName,
		&i.ContextType,
		&i.Context,
		&i.Key,
		&i.Timestamp,
		&i.UserId,
		&i.TeamId,
		&i.PipelineRun,
		&i.State,
		&i.SigStatus,
		&i.Alerted,
		&i.License,
		&i.Deleted,
		pq.Array(&i.JobIds),
		&i.Txt,
		&i.Project,
		&i.LogicalApp,
		&i.LogicalAppVersion,
		&i.Tool,
	)
	return i, err
}

const listEvidence = `-- name: ListEvidence :many
SELECT
    "id",
    "contentType",
    "contextType",
    "context" ,
    "key",    -- S3 URI
    "timestamp" ,
    "userId",  -- ref osint.User.id,
    "teamId",  -- ref osint.Team.id" -- makes attestation private
    "license",
    "txt", -- full-text search
    "state"
FROM
    osint."Attestation"
WHERE
    ($1::jsonb <@context::jsonb) AND
    ($2::BIGINT = "teamId")
`

type ListEvidenceParams struct {
	Input  json.RawMessage `json:"input"`
	Teamid int64           `json:"teamid"`
}

type ListEvidenceRow struct {
	ID          int64           `json:"id"`
	ContentType string          `json:"contenttype"`
	ContextType string          `json:"contexttype"`
	Context     json.RawMessage `json:"context"`
	Key         *string         `json:"key"`
	Timestamp   sql.NullTime    `json:"timestamp"`
	UserId      *int64          `json:"userid"`
	TeamId      *int64          `json:"teamid"`
	License     *string         `json:"license"`
	Txt         interface{}     `json:"txt"`
	State       string          `json:"state"`
}

func (q *Queries) ListEvidence(ctx context.Context, arg ListEvidenceParams) ([]ListEvidenceRow, error) {
	rows, err := q.query(ctx, q.listEvidenceStmt, listEvidence, arg.Input, arg.Teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEvidenceRow
	for rows.Next() {
		var i ListEvidenceRow
		if err := rows.Scan(
			&i.ID,
			&i.ContentType,
			&i.ContextType,
			&i.Context,
			&i.Key,
			&i.Timestamp,
			&i.UserId,
			&i.TeamId,
			&i.License,
			&i.Txt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setEvidenceState = `-- name: SetEvidenceState :exec
UPDATE
    osint."Attestation"
SET
    state = $1
WHERE
    id = $2::BIGINT
`

type SetEvidenceStateParams struct {
	State string `json:"state"`
	ID    int64  `json:"id"`
}

func (q *Queries) SetEvidenceState(ctx context.Context, arg SetEvidenceStateParams) error {
	_, err := q.exec(ctx, q.setEvidenceStateStmt, setEvidenceState, arg.State, arg.ID)
	return err
}

const updateContext = `-- name: UpdateContext :exec
UPDATE
    osint."Attestation"
SET
    context = $1::JSONB
WHERE
    id = $2::BIGINT
`

type UpdateContextParams struct {
	Context json.RawMessage `json:"context"`
	ID      int64           `json:"id"`
}

func (q *Queries) UpdateContext(ctx context.Context, arg UpdateContextParams) error {
	_, err := q.exec(ctx, q.updateContextStmt, updateContext, arg.Context, arg.ID)
	return err
}
